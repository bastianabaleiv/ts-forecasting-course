---
title: "Clase 3"
description: |
  Series de tiempo en R: evaluando modelos basados en caracterÃ­sticas
author:
  - name: BastiÃ¡n Aballay L.
    url: https://www.linkedin.com/in/bastianaballay/
date: "2021-11-08"
bibliography: clase-03.bib
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
    toc_float: true
    code_folding: true
    highlight: tango
    self_contained: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r packages, include=FALSE}
suppressPackageStartupMessages(library(tidyverse))

library(xaringanExtra)
xaringanExtra::use_panelset()
```

En la [Clase 2](https://hapst.netlify.app/posts/clase-02/) revisamos los aspectos teÃ³ricos bÃ¡sicos
que nos permiten caracterizar a las series de tiempo.

En esta clase revisaremos las series de tiempo desde una perspectiva prÃ¡ctica,
estableciendo los requerimientos necesarios para lograr manipularlas, agregarlas y
pronosticarlas usando ecosistemas de `R`. Luego de esta clase podrÃ¡s:

+ Conocer los requerimientos tÃ©cnicos (*packages*) para trabajar con series de tiempo en `R`
+ Manipular y agregar series de tiempo
+ Entender el proceso de evaluaciÃ³n de pronÃ³sticos a travÃ©s del tiempo
+ Definir indicadores de desempeÃ±o adecuados para evaluar modelos de pronÃ³stico
+ Entender la importancia de establecer una modelo ingenuo como pronÃ³stico inicial
+ Generar caracterÃ­sticas para modelos de pronÃ³stico a partir del Ã­ndice temporal asociado a la serie
+ Modelar series de tiempo utilizando el RegresiÃ³n Lineal 

# Objetos de R para Series de Tiempo

Desde la perspectiva programÃ¡tica, una serie de tiempo es una serie de observaciones
cuyo principal atributo es poseer un *Ã­ndice temporal* (*timestamp*) asociado a cada
una de ellas. Dicho Ã­ndice puede tomar la forma de un objeto de `R` tipo `date`,
un objeto temporal u otro formato dependiendo de la frecuencia de la serie. La 
generaciÃ³n de dicho Ã­ndice a partir de datos *raw* no es trivial y en general
requerirÃ¡ de un preprocesamiento o formateo de los datos a un formato de series de tiempo.
Es por ello que conocer los ecosistemas que permitan al pracicante ser capaz de trabajar con 
perÃ­odos temporales y fechas se vuelve esencial.

## base ğŸ§“ğŸ‘´

### Date

En ciertos lugares existen diferentes convenciones para trabajar con fechas (*dates*). 

```{r dates, echo = FALSE, fig.cap = "Fuente: [Date Format in the United States](https://iso.mit.edu/americanisms/date-format-in-the-united-states/)"}
knitr::include_graphics("https://iso.mit.edu/wp-content/uploads/2020/01/am_dateformat.gif")
```

Sin embargo, existe un estÃ¡ndar global (ISO 8601 YYYY-MM-DD) que especifica la 
manera correcta para lidiar con fechas evitando toda confusiÃ³n: ordenando los 
componentes de manera decreciente (aÃ±os &rarr; meses &rarr; dÃ­as). Cada valor
posee una cantidad fija de digitos, por lo que es necesario rellenar con ceros
algunos meses (i.e Septiembre: mes 9 &rarr; `09`). La mejor manera de indicar a `R`
que nos encontramos trabajando con fechas es declararlo de manera explÃ­cita
utilizando el mÃ©todo `as.Date` sobre un string con una fecha en formato ISO.

```{r}
2021-11-08 # No es una fecha
str("2021-11-08") # String con una fecha
as.Date("2021-11-08")
str(as.Date("2021-11-08"))
```

Trasbambalinas, los objetos tipo `Date` son almacenados como los dÃ­as 
transcurridos desde `1970-01-01`, lo que significa que es posible llevar a cabo
comparaciones matemÃ¡ticas con ellas.

```{r}
# Â¿Es hoy mayor que ayer?
as.Date("2021-11-08") > as.Date("2021-11-07")
```

```{r}
# Â¿Que fecha era hace un dia (una unidad de tiempo) atras?
as.Date("2021-11-08") - 1
```

```{r}
# Â¿Cuantos dias han pasado desde la ultima clase?
as.Date("2021-11-08") - as.Date("2021-10-25")
```

Si contamos con fechas, podemos hacer uso de la potencia de `R` para graficar:

```{r}
x <- c(
  as.Date("2021-11-08"),
  as.Date("2021-10-08"),
  as.Date("2021-09-08"),
  as.Date("2021-08-08"),
  as.Date("2021-07-08")
)
set.seed(2021)
y <- rnorm(5)

plot(x, y, type = "b")
```

```{r}
ggplot() +
  geom_line(aes(x = x, y = y)) +
  geom_point(aes(x = x, y = y))
```

Podemos obtener la fecha del sistema en el que nos encontremos trabajando con
`Sys.Date()`

```{r}
Sys.Date()
```

### Time

Continuando la idea de `ISO 8601`, para incorporar un perÃ­odo en especÃ­fico continuamos
definiendo elementos de manera decreciente: `HH:MM:SS`, donde las horas poseen dos
dÃ­gitos fijos (`00` - `24`) asÃ­ como tambiÃ©n los minutos (`00` - `59`) y segundos, pudiendo existir sin separador o con `:`.

Existen dos tipos de fechas en `R`:

* `POSIXlt`: lista con componentes nombrados
* `POSIXct`: segundos desde `1970-01-01 00:00:00`, la coersiÃ³n desde un string
se lleva cabo mediante `as.POSIXct()`

```{r}
lesson3_date <- as.POSIXct("2021-11-08 19:00:00")
str(lesson3_date)
```

### Timezone

La `ISO 8601` tambiÃ©n permite especificar zonas, asumiendose zona local ante la 
ausencia de su definiciÃ³n.

```{r}
# Coordinated Universal Time
as.POSIXct("2021-11-08 19:00:00", tz = "UTC")
```

La operatoria aritmÃ©tica revisada con datos del tipo `Date` se extiende a los 
datos tipo `POSIXct`.

## lubridate â°

A medida que los requerimientos de manipulaciÃ³n de datos han evolucionado a travÃ©s
del tiempo, tambiÃ©n lo han hecho los paquetes con los cuales se abordan dichos
desafÃ­os. `lubridate` es un paquete de `R` que permite trabajar de manera fÃ¡cil
con tiempos y fechas^[AdemÃ¡s de format parte del [`tidyverse`](https://lubridate.tidyverse.org/)].

Veamos como trabajar fechas a partir de distintos formatos:

```{r}
lubridate::ymd("2021-11-08")
lubridate::dmy("08/11/2021")
lubridate::parse_date_time("Sep 11th, 2021", order = c("mdy"))
lubridate::parse_date_time("11th Sep 2021", order = c("dmy"))
```
```{r}
lubridate::year("2021-11-08")
lubridate::month("2021-11-08")
lubridate::month("2021-11-08", label = TRUE)
lubridate::day("2021-11-08")
lubridate::wday("2021-11-08", label = TRUE)
lubridate::yday("2021-11-08")
```

```{r}
lubridate::ymd_hm("2021-11-08 07:00pm")
lubridate::hour("2021-11-08 07:00pm")
lubridate::minute("2021-11-08 07:00pm")
```

```{r}
# Chile because of reasons
lubridate::with_tz("2021-11-08", "America/Santiago") 
```

```{r}
lubridate::make_date(year = 2021L, month = 11L, day = 8L)
lubridate::make_datetime(year = 2021L, month = 11L, day = 8L, hour = 7L, min = 0L)
```

```{r}
lubridate::quarter("2021-11-08 07:00pm")
lubridate::semester("2021-11-08 07:00pm")
lubridate::leap_year("2021-11-08 07:00pm")
```

Podemos restar fechas utilizando `difftime()`

```{r}
difftime("2021-11-08", "2021-10-25", units = "weeks")
```

Ahora

```{r}
lubridate::now()
```
Hoy

```{r}
lubridate::today()
```

En una semana mÃ¡s

```{r}
lubridate::today() + lubridate::days(7)
```

En particular, cabe destacar dos definiciones en `lubridate` para intervalos 
temporales

+ `period`: perÃ­odo o concepto humano de intervalo temporal. Una fecha (*datetime*) + un perÃ­odo de un dÃ­a = mismo momento en la fecha siguiente.
+ `duration`: duraciÃ³n o concepto *cronometrado* del tiempo. Una fecha + un perÃ­odo de un dÃ­a = fecha + 86400 segundos.

Veamos la diferencia

```{r}
lubridate::days(x = 7)
lubridate::ddays(7)
```


![Lubridate CheatSheet](https://rawgit.com/rstudio/cheatsheets/main/lubridate.pdf){width=100% height=400}

## `ts()` ğŸ’Š

Supongamos que tenemos los siguientes datos:

| AÃ±o  | ObservaciÃ³n | 
| ---  | ----------- |
| 2017 | 20          |
| 2018 | 30          |
| 2019 | 60          |
| 2020 | 40          |
| 2021 | 25          |

Podemos almacenar una serie de tiempo en un objeto tipo `ts` utilizando la 
funciÃ³n `ts()`.

```{r}
set.seed(2021)
y <- ts(rnorm(5), start=2017)
```

Es posible asociar observaciones que poseen una frecuencia mayor que la anual utilizando el argumento `frequency`

```{r}
set.seed(2021)
y <- ts(rnorm(12*5), start=2017, frequency = 12)
```

En este caso, las frecuencias se definen como sigue

| Dato       | Frecuencia  | 
| ---------  | ----------- |
| Anual      |     1       |
| Trimestral |     4       |
| Mensual    |     12      |
| Semanal    |     52^[En un aÃ±o hay $365.25/7 = 52.18$ semanas en promedio, sin embargo, los objetos `ts` requieren de frecuencia dictadas por nÃºmeros enteros.] |

> Â¿QuÃ© ocurre si la frecuencia de mis observaciones es mayor a la semanal?

En el caso de utilizar objetos `ts`, es necesario decidir que frecuencia
es mÃ¡s representativa de la serie^[[fpp2: `ts` objects](https://otexts.com/fpp2/ts-objects.html)] considerando efectos como la estacionalidad (en
caso de que aplique).

## `zoo()` y `xts()` ğŸ’ŠğŸ’Š

## `tsibble()` ğŸ’ŠğŸ’ŠğŸ’Š

## `timetk()` ğŸ’ŠğŸ’ŠğŸ’ŠğŸ’ŠğŸš€

# EvaluaciÃ³n de pronÃ³sticos ğŸ¤”ğŸ“

## Set de entrenamiento y test ğŸ”ª

La precisiÃ³n de un pronÃ³stico sÃ³lo puede ser determinada considerando quÃ© tan 
bien se desempeÃ±an los pronÃ³sticos generados en datos nuevos que no han sido 
utilizados para ajustar el modelo (@Hyndman2021-hc). AsÃ­, al igual que como
se evalÃºan los modelos de Machine Learning, es una prÃ¡ctica comÃºn separar
los datos disponibles en dos conjuntos, un conjunto de ajuste o *entrenamiento*
(*training set*)^[a.k.a. *in-sample data*] y otro de evaluaciÃ³n 
(*test set*)^[a.k.a. *out-sample data*, *hold-out set*], 
donde los datos de entrenamiento son utilizados para estimar los parÃ¡metros de cualquier 
mÃ©todo de pronÃ³stico y los datos de evaluaciÃ³n son utilizados para determinar su precisiÃ³n. 
Dado que los datos de evaluaciÃ³n no son utilizados en el proceso de elaboraciÃ³n
de los pronÃ³sticos, Ã©stos nos permiten obtener un indicador confiable de quÃ© tan
bien puede pronosticar un modelo los datos nuevos. 

<aside>
<p>Training Set</p>
<p>Test Set</p>
</aside>

Al momento de evaluar el desempeÃ±o de modelos de pronÃ³stico es necesario
distinguir entre un *pronÃ³stico* (*forecast*) o *valor predicho* (*predicted value*)
de $y_t$, realizado en algÃºn perÃ­odo previo, por ejemplo $t-\tau$, y un
*valor ajustado* (*fitted value*) de $y_t$, que ha resultado de estimar los parÃ¡metros
de un modelo de series de tiempo en datos histÃ³ricos, generando *residuales*.

El mÃ©todo mÃ¡s comÃºn para evaluar el Ã©xito de un pronÃ³stico para predecir los valores
reales es utilizar mÃ©tricas de precisiÃ³n o error. AquÃ­ *error* no debe entenderse
como una equivocaciÃ³n, sino como la parte impredecible de una observaciÃ³n.
La selecciÃ³n de la mÃ©trica especÃ­fica de error dependerÃ¡ de los objetivos de 
pronÃ³stico de que se tengan.

<aside>
Error de pronÃ³stico
</aside>

El tamaÃ±o del set de evaluaciÃ³n depende de quÃ© tanta informaciÃ³n se posea y quÃ©
tan adelante se quiera pronosticar. Es ideal que el test set tenga al menos
el largo del horizonte de pronÃ³stico mÃ¡ximo requerido.

Algunas observaciones a considerar

+ Un modelo que se ajusta bien a los datos de entrenamiento no necesariamente
pronosticarÃ¡ bien.
+ Siempre es posible obtener un ajuste perfecto usando un modelo con una cantidad
de parÃ¡metros suficiente^[Por ejemplo, redes neuronales]
+ *Sobreajustarse* (*over-fit*) un modelo a los datos es tan malo como fallar en
identificar los patrones sistemÃ¡ticos en ellos.

## ValidaciÃ³n Cruzada para Series de Tiempo (TSCV) ğŸ“

Mencionar revisiÃ³n de [TSCV](https://hapst.netlify.app/posts/clase-01/index.html#forecastingprocess) 
en clase 01.

## Modelos benchmark (naive) ğŸ˜Œ

## AnÃ¡lisis de residuales ğŸš¯

El anÃ¡lisis de residuales permite analizar quÃ© tan bien el modelo captura e identifica
los patrones de la serie. AdemÃ¡s, podemos elaborar intervalos de confianza para los pronÃ³sticos generados a partir de la distribuciÃ³n de los residuales. Podemos definir a los residuales como la diferencia entre el valor real observado ($y_i$) y su correspondiente valor ajustado por el modelo ($\hat{y_i}$), para cada $i = 1, \dots, T$. 

## MÃ©tricas de desempeÃ±o ğŸ’¯

### MAE

En el *error absoluto medio* (*Mean Absolute Error* (MAE)), el error de pronÃ³stico
estÃ¡ en la misma escala que los datos originales. Debido a lo anterior, no puede
ser utilizado para comparar desempeÃ±o entre series que involucren distintas unidades
de medida. Un mÃ©todo de pronÃ³stico que minimice el MAE conducirÃ¡ a pronosticos
de la mediana. Este mÃ©todo no es sensible a outliers.

$$MAE = \frac{1}{T}\sum_{t=1}^{T}\left|y_{t}-\hat{y}_{t}\right|$$

### MSE

El error cuadrÃ¡tico medio (*Mean Squared Error* (MSE)) cuantifica la distancia al 
cuadrado promedio entre los valores reales y los pronosticados. 
El efecto de elevar al cuadrado previene que los valores negativos
y positivos se cancelen entre sÃ­, penalizando el error si es muy elevado.
Un mÃ©todo de pronÃ³stico que minimice el MSE conducirÃ¡ a pronosticos
de la media.

$$MSE = \frac{1}{T}\sum_{t=1}^{T}(y_t - \hat{y}_t)^2$$

### RMSE

Similar a MSE, en las unidades de las observaciones.

$$RMSE = \sqrt{MSE} = \sqrt{\frac{1}{T}\sum_{t=1}^{T}(y_t - \hat{y}_t)^2}$$

### MAPE

El error porcentual absoluto medio (*Mean Absolute Percentage Error* (MAPE)) es una
de las mÃ©tricas mÃ¡s fÃ¡ciles de comparar y comunicar con interlocutores no-tÃ©cnicos
dado que representa un porcentaje. Los errores porcentuales poseen la ventaja de 
no tener unidades y son utilizados para comparar el desempeÃ±o de un modelo
de pronÃ³stico entre datasets. Sin embargo, poseen la desventaja de ser infintos
o indefinidos si $y_t = 0$ para cualquier periodo de interÃ©s $t$, ademÃ¡s de tener
valores extremos cuando $y_t$ es cercano a cero. AdemÃ¡s, poseen la desventaja
de penalizar errores negativos mÃ¡s que los positivos, lo que condujo a la 
elaboraciÃ³n de otra mÃ©trica porcentual llamada sMAPE (*symmetric MAPE*), usado
en la competencia M3.

$$MAPE = \frac{1}{T}\sum _{t=1}^{T}\bigg(\frac{|y_{t}-\hat{y}_{t}|}{y_{t}}\bigg)\times100$$

### SMAPE

$$SMAPE = {\frac{1}{T}\sum _{t=1}^{T}\bigg(\frac{2|y_{t}âˆ’\hat{y}_{t}|}{y_{t}+\hat{y}_{t}}\bigg)\times 100}$$ 


### $R^{2}$

$$R^{2} = {1-{\frac {\sum _{t=1}^{T}\left(y_{t}-\hat{y}_{t}\right)}{\sum _{i=1}^{T}\left(y_{t}-\bar{y}_{t}\right)}}}$$

## EvaluaciÃ³n de desempeÃ±o en R ğŸ“š

Podemos encontrar las mÃ©tricas revisadas anteriormente en los siguientes
paquetes:

+ [`Metrics`](https://cran.r-project.org/web/packages/Metrics/index.html)
+ [`yardstick`](https://yardstick.tidymodels.org/) 

# RegresiÃ³n Lineal para pronÃ³stico de series de tiempo ğŸ“ˆâœ¨


